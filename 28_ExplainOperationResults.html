<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

	<script type="text/javascript">
		'use strict';

		// 1. If input is primitive, return it as is.
		// 2. Otherwise, input is an object. Call obj.valueOf(). If the result is primitive, return it.
		// 3. Otherwise, call obj.toString(). If the result is a primitive, return it.
		// 4. Otherwise, throw a TypeError.

		console.log('12345');
		console.log('=========');
		// So according to the above rules  
		// valueof [] === array, not primitive
		// toString returns an empty string wich is primitive
		// adding to empty strings results in an empty string
		console.log('[]+[]');
		var x1 = []+[];
		console.log('typeof: ', typeof x1);
		console.log('value:', x1.length);
		
		console.log('===========');
		// Converting an empty object to string yields the following result:
		// String({}) = '[object Object]'
		// so the result is "" + '[object Object]'
		console.log('[]+{}');
		var x2 = []+{};
		console.log('typeof: ', typeof x2);
		console.log('value', x2);
		
		console.log('===========');
		// in {}+{}, JavaScript interprets the first {} as an empty code block and ignores it. The NaN is therefore computed by evaluating +{} (plus followed by the second {}). The "plus" you see here is not the binary addition operator, but a unary prefix operator that converts its operand to a number, in the same manner as Number(). For example:
		// > +"3.65"
		// 3.65
		// so {} + Number({}) = NaN
		console.log('{}+{}');
		var x3 = {}+{};
		console.log('typeof: ', typeof x3);
		console.log('value', x3);
		
		console.log('===========');
		// Following previous explanation, empty code block and converting array to number give us 0
		console.log('{}+[]');
		var x4 = {}+[];
		console.log('typeof: ', typeof x4);
		console.log('value', x4);

	</script>
</body>
</html>